import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';

/**
 * Spec-Kit Task Reader - v5.0
 *
 * Reads and parses tasks generated by Spec-Kit's /tasks command
 * Extracts task dependencies, ordering, and execution metadata
 */

export interface Task {
  id: string;
  title: string;
  description: string;
  dependencies: string[];
  priority: 'high' | 'medium' | 'low';
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  estimatedDuration?: string;
  tags?: string[];
}

export interface TaskGraph {
  tasks: Task[];
  executionOrder: string[]; // Task IDs in execution order
  rootTasks: string[]; // Tasks with no dependencies
  leafTasks: string[]; // Tasks with no dependents
}

export class SpecKitTaskReader {
  private specifyDir: string;

  constructor(workingDir: string) {
    this.specifyDir = path.join(workingDir, '.specify');
  }

  /**
   * Check if Spec-Kit is initialized
   */
  isInitialized(): boolean {
    return fs.existsSync(this.specifyDir);
  }

  /**
   * Get the most recent feature directory
   */
  getLatestFeatureDir(): string | null {
    const specsDir = path.join(this.specifyDir, 'specs');

    if (!fs.existsSync(specsDir)) {
      return null;
    }

    const featureDirs = fs
      .readdirSync(specsDir)
      .filter((name) => {
        const fullPath = path.join(specsDir, name);
        return fs.statSync(fullPath).isDirectory();
      })
      .sort(); // Usually numbered like 001-feature-name

    if (featureDirs.length === 0) {
      return null;
    }

    return path.join(specsDir, featureDirs[featureDirs.length - 1]);
  }

  /**
   * Read tasks from the latest feature directory
   */
  async readGeneratedTasks(): Promise<Task[]> {
    const featureDir = this.getLatestFeatureDir();

    if (!featureDir) {
      console.log(chalk.yellow('‚ö†Ô∏è  No feature directories found in .specify/specs/'));
      return [];
    }

    const tasksFile = path.join(featureDir, 'tasks.md');

    if (!fs.existsSync(tasksFile)) {
      console.log(chalk.yellow(`‚ö†Ô∏è  No tasks.md found in ${featureDir}`));
      return [];
    }

    const content = fs.readFileSync(tasksFile, 'utf-8');
    return this.parseTasksMarkdown(content);
  }

  /**
   * Parse tasks from markdown format
   */
  private parseTasksMarkdown(content: string): Task[] {
    const tasks: Task[] = [];
    const lines = content.split('\n');

    let currentTask: Partial<Task> | null = null;
    let taskCounter = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Task header: ## Task N: Title or ### Task N: Title
      const taskHeaderMatch = line.match(/^#{2,3}\s+(?:Task\s+)?(\d+)[:.]\s+(.+)$/i);
      if (taskHeaderMatch) {
        // Save previous task
        if (currentTask && currentTask.title) {
          tasks.push(this.finalizeTask(currentTask, taskCounter++));
        }

        // Start new task
        currentTask = {
          title: taskHeaderMatch[2].trim(),
          description: '',
          dependencies: [],
          priority: 'medium',
          status: 'pending',
          tags: []
        };
        continue;
      }

      // Alternative format: - [ ] Task title
      const checkboxMatch = line.match(/^-\s+\[\s*\]\s+(.+)$/);
      if (checkboxMatch) {
        if (currentTask && currentTask.title) {
          tasks.push(this.finalizeTask(currentTask, taskCounter++));
        }

        currentTask = {
          title: checkboxMatch[1].trim(),
          description: '',
          dependencies: [],
          priority: 'medium',
          status: 'pending',
          tags: []
        };
        continue;
      }

      // Completed task: - [x] Task title
      const completedMatch = line.match(/^-\s+\[x\]\s+(.+)$/i);
      if (completedMatch) {
        if (currentTask && currentTask.title) {
          tasks.push(this.finalizeTask(currentTask, taskCounter++));
        }

        currentTask = {
          title: completedMatch[1].trim(),
          description: '',
          dependencies: [],
          priority: 'medium',
          status: 'completed',
          tags: []
        };
        continue;
      }

      // Description or metadata
      if (currentTask && line) {
        // Priority indicator
        if (line.toLowerCase().includes('priority:')) {
          const priority = line.toLowerCase().includes('high')
            ? 'high'
            : line.toLowerCase().includes('low')
            ? 'low'
            : 'medium';
          currentTask.priority = priority;
        }
        // Dependencies
        else if (line.toLowerCase().includes('depends on:') || line.toLowerCase().includes('requires:')) {
          const depMatch = line.match(/(?:depends on|requires):\s*(.+)/i);
          if (depMatch) {
            currentTask.dependencies = depMatch[1]
              .split(',')
              .map((d) => d.trim())
              .filter((d) => d.length > 0);
          }
        }
        // Estimated duration
        else if (line.toLowerCase().includes('estimated:') || line.toLowerCase().includes('duration:')) {
          const durationMatch = line.match(/(?:estimated|duration):\s*(.+)/i);
          if (durationMatch) {
            currentTask.estimatedDuration = durationMatch[1].trim();
          }
        }
        // Tags
        else if (line.includes('#') && !line.startsWith('#')) {
          const tags = line.match(/#[\w-]+/g);
          if (tags) {
            currentTask.tags = tags.map((t) => t.substring(1));
          }
        }
        // Regular description
        else if (!line.startsWith('-') && !line.startsWith('*')) {
          if (currentTask.description) {
            currentTask.description += ' ' + line;
          } else {
            currentTask.description = line;
          }
        }
      }
    }

    // Don't forget the last task
    if (currentTask && currentTask.title) {
      tasks.push(this.finalizeTask(currentTask, taskCounter++));
    }

    return tasks;
  }

  /**
   * Finalize a task with default values
   */
  private finalizeTask(task: Partial<Task>, index: number): Task {
    return {
      id: task.id || `task-${index + 1}`,
      title: task.title || 'Untitled Task',
      description: task.description || '',
      dependencies: task.dependencies || [],
      priority: task.priority || 'medium',
      status: task.status || 'pending',
      estimatedDuration: task.estimatedDuration,
      tags: task.tags || []
    };
  }

  /**
   * Build task execution graph from dependencies
   */
  parseTaskBreakdown(tasks: Task[]): TaskGraph {
    const taskMap = new Map<string, Task>();
    const dependents = new Map<string, Set<string>>();

    // Build task map and reverse dependency graph
    tasks.forEach((task) => {
      taskMap.set(task.id, task);
      dependents.set(task.id, new Set());
    });

    // Build dependent relationships
    tasks.forEach((task) => {
      task.dependencies.forEach((depId) => {
        // Try to match by ID or title
        const depTask = tasks.find((t) => t.id === depId || t.title === depId);
        if (depTask) {
          dependents.get(depTask.id)?.add(task.id);
        }
      });
    });

    // Find root tasks (no dependencies)
    const rootTasks = tasks
      .filter((t) => t.dependencies.length === 0)
      .map((t) => t.id);

    // Find leaf tasks (no dependents)
    const leafTasks = tasks
      .filter((t) => dependents.get(t.id)?.size === 0)
      .map((t) => t.id);

    // Topological sort for execution order
    const executionOrder = this.topologicalSort(tasks, taskMap);

    return {
      tasks,
      executionOrder,
      rootTasks,
      leafTasks
    };
  }

  /**
   * Topological sort to determine execution order
   */
  private topologicalSort(tasks: Task[], taskMap: Map<string, Task>): string[] {
    const visited = new Set<string>();
    const order: string[] = [];

    const visit = (taskId: string) => {
      if (visited.has(taskId)) return;
      visited.add(taskId);

      const task = taskMap.get(taskId);
      if (!task) return;

      // Visit dependencies first
      task.dependencies.forEach((depId) => {
        const depTask = tasks.find((t) => t.id === depId || t.title === depId);
        if (depTask) {
          visit(depTask.id);
        }
      });

      order.push(taskId);
    };

    tasks.forEach((task) => visit(task.id));

    return order;
  }

  /**
   * Get next executable tasks (dependencies satisfied)
   */
  getNextExecutableTasks(graph: TaskGraph): Task[] {
    const completedIds = new Set(
      graph.tasks.filter((t) => t.status === 'completed').map((t) => t.id)
    );

    return graph.tasks.filter((task) => {
      // Already completed or in progress
      if (task.status === 'completed' || task.status === 'in_progress') {
        return false;
      }

      // Check if all dependencies are completed
      return task.dependencies.every((depId) => {
        const depTask = graph.tasks.find((t) => t.id === depId || t.title === depId);
        return depTask ? completedIds.has(depTask.id) : true;
      });
    });
  }

  /**
   * Update task status
   */
  updateTaskStatus(
    taskId: string,
    status: Task['status'],
    tasks: Task[]
  ): Task[] {
    return tasks.map((task) =>
      task.id === taskId ? { ...task, status } : task
    );
  }

  /**
   * Display task graph in terminal
   */
  displayTaskGraph(graph: TaskGraph): void {
    console.log(chalk.bold('\nüìã Spec-Kit Task Breakdown:\n'));

    graph.executionOrder.forEach((taskId, index) => {
      const task = graph.tasks.find((t) => t.id === taskId);
      if (!task) return;

      const statusIcon =
        task.status === 'completed'
          ? chalk.green('‚úì')
          : task.status === 'in_progress'
          ? chalk.yellow('‚è≥')
          : task.status === 'failed'
          ? chalk.red('‚úó')
          : chalk.gray('‚èπ');

      const priorityBadge =
        task.priority === 'high'
          ? chalk.red('[HIGH]')
          : task.priority === 'low'
          ? chalk.gray('[LOW]')
          : '';

      const isLast = index === graph.executionOrder.length - 1;
      const prefix = isLast ? '‚îî‚îÄ' : '‚îú‚îÄ';

      console.log(`   ${prefix} ${statusIcon} ${chalk.white(task.title)} ${priorityBadge}`);

      if (task.description && task.description.length > 0) {
        console.log(chalk.gray(`      ${task.description.substring(0, 60)}...`));
      }

      if (task.dependencies.length > 0) {
        console.log(
          chalk.gray(
            `      Depends on: ${task.dependencies.join(', ')}`
          )
        );
      }
    });

    console.log();
  }

  /**
   * Save task state to file
   */
  saveTaskState(tasks: Task[], featureDir?: string): void {
    const targetDir = featureDir || this.getLatestFeatureDir();
    if (!targetDir) return;

    const stateFile = path.join(targetDir, 'task-state.json');
    fs.writeFileSync(stateFile, JSON.stringify(tasks, null, 2));
  }

  /**
   * Load task state from file
   */
  loadTaskState(featureDir?: string): Task[] | null {
    const targetDir = featureDir || this.getLatestFeatureDir();
    if (!targetDir) return null;

    const stateFile = path.join(targetDir, 'task-state.json');
    if (!fs.existsSync(stateFile)) return null;

    const content = fs.readFileSync(stateFile, 'utf-8');
    return JSON.parse(content);
  }
}
